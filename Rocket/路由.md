# 路由

一个完整的路由两部分组成：

- 一组用于匹配传入请求的参数。
- 处理请求并返回响应的处理程序。

处理程序只是一个函数，它接受任意数量的参数并返回任意类型。

### 定义路由

使用属性宏生成一个路由。

```rust
#[route(GET, uri = "/")]
fn index() -> &' static str{
    "Hello, world"
}
```

7个方法路由宏：get、put、post、delete、head、options、patch。

```rust
#[get("/")]
fn index() -> &' static str{
    "Hello, world"
}
```

### 动态路径

##### 路径参数

在匹配路径上使用语法 `<param>` 定义一个参数，通过处理函数的入参进行访问，路径的参数名和函数的参数名需一致。

```rust
#[get("/hello/<name>")]
fn hello(name: &str) -> String {
    format!("Hello, {}!", name)
}
```

同时也可以定义多个参数。

```rust
#[get("/hello/<name>/<age>/<cool>")]
fn hello(name: &str, age: u8, cool: bool) -> String {
    if cool {
        format!("You're a cool {} year old, {}!", age, name)
    } else {
        format!("{}, we need to talk about your coolness.", name)
    }
}
```

使用 `<param..>` 进行多段匹配，剩余层级都可以匹配上。

```rust
use std::path::PathBuf;

#[get("/page/<path..>")]
fn get_page(path: PathBuf) { /* ... */ }

// 比如 /page/web/a.html ， path 值就是 web/a.html。
```

使用 `<_>` 忽略中间段。

```rust
#[get("/foo/<_>/bar")]
fn foo_bar() -> &'static str {
    "Foo _____ bar!"
}
// 以下路由均可匹配上：
// /foo/aaa/bar
// /foo/a/a/a/bar
// 但是 /foo/bar 是匹配不了的
```

通过结合多段匹配和忽略中间段 `<_..>` 实现匹配所有请求。

```rust
#[get("/<_..>")]
fn everything() -> &'static str {
    "Hey, you're here."
}
```

### 路径透传

##### 根据参数类型透传

当一个路径参数可以匹配多种类型的时候，可以进行路径透传，类似重载功能。

```rust
#[get("/user/<id>")]
fn user(id: usize) { /* ... */ }

#[get("/user/<id>", rank = 2)]
fn user_int(id: isize) { /* ... */ }

#[get("/user/<id>", rank = 3)]
fn user_str(id: &str) { /* ... */ }

#[launch]
fn rocket() -> _ {
    rocket::build().mount("/", routes![user, user_int, user_str])
}
```

把需要透传的路由处理函数都挂载到一个路由里面。通过 rank 来实现透传路由的函数调用顺序。如果没有明确指定 rank，Rocket 会分配一个默认值，默认值在 -12 到 -1 之间。在路径和查询中，默认排名优先于静态段而不是动态段：路由的路径和查询越静态，其优先级越高。

##### 根据请求守卫透传

当一个路径需要不同的请求守卫处理的时候，可以进行请求守卫透传。

```rust
use rocket::response::Redirect;

#[get("/login")]
fn login() -> Template { /* .. */ }

#[get("/admin")]
fn admin_panel(admin: AdminUser) -> &'static str {
    "Hello, administrator. This is the admin panel!"
}

#[get("/admin", rank = 2)]
fn admin_panel_user(user: User) -> &'static str {
    "Sorry, you must be an administrator to access this page."
}

#[get("/admin", rank = 3)]
fn admin_panel_redirect() -> Redirect {
    Redirect::to(uri!(login))
}
```

和参数类型类似，都是使用 `rank` 来定义透传的跳用顺序，与参数类型透传不一样的时候，请求守卫透传可以人工控制是否继续透传。

### 路由跳转

```rust
#[get("/admin")]
fn admin_panel_redirect() -> Redirect {
    Redirect::to(uri!(login))
}
```

